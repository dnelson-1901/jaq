# Advanced features


## Assignments

Like jq, jaq allows for assignments of the form `p |= f`.
However, jaq interprets these assignments differently.
Fortunately, in most cases, the result is the same.

In jq, an assignment `p |= f` first constructs paths to all values that match `p`.
*Only then*, it applies the filter `f` to these values.

In jaq, an assignment `p |= f` applies `f` *immediately* to any value matching `p`.
Unlike in jq, assignment does not explicitly construct paths.

jaq's implementation of assignment likely yields higher performance,
because it does not construct paths.
Furthermore, this allows jaq to use multiple outputs of the right-hand side, whereas
jq uses only the first.
For example,
`0 | (., .) |= (., .+1) --> 0 1 1 2` in jaq,
whereas it yields only `0` in jq.
However,
`{a: 1} | .a |= (2, 3) --> {"a": 2}` in both jaq and jq,
because an object can only associate a single value with any given key,
so we cannot use multiple outputs in a meaningful way here.

Because jaq does not construct paths,
it does not allow some filters on the left-hand side of assignments,
for example `first`, `last`, `limit`:
For example, `[1, 2, 3] | first(.[]) |= .-1`
yields `[0, 2, 3]` in jq, but is invalid in jaq.
Similarly, `[1, 2, 3] | limit(2; .[]) |= .-1`
yields `[0, 1, 3]` in jq, but is invalid in jaq.
(Inconsequentially, jq also does not allow for `last`.)

::: Compatibility
In jq, `[0, 1] | .[3] = 3` yields `[0, 1, null, 3]`; that is,
jq fills up the list with `null`s if we update beyond its size.
In contrast, jaq fails with an out-of-bounds error in such a case.
:::

### Path-based

The path-based update model that is used by `jq` executes `p |= u` similar to
`getpath(path(p)) |= u`.
That means that this first collects the paths corresponding to `p`,
then updates the input at these paths by `u`.
Note that this is an approximation;
the actual `jq` update behaviour is rather complex,
not exhaustively documented, and
has changed in backwards-incompatible ways between minor versions.

We have a few equivalences for `path(f)`:

| `p`           | `path(p)` |
|:--------------|:----------|
| `.`           | `[]` |
| `.[]`         | `keys_unsorted` |
| `.[$i]`       | `[$i]` |
| `.[$i:$j]`    | `{start: $i, end: $j}` |
| `f,  g`       | `path(f), path(g)` |
| `f | g`       | `path(f) as $p | $p + (getpath($p) | path(g))` |
| `f as $x | g` | `f as $x | path(g)` |
| `if $p then f else g end` | `if $p then path(f) else path(g) end` |

### Pathless

The pathless update model that is used by jaq
reduces updates `p |= u` to simpler expressions, depending on `p`.
It yields the same results as path-based updates in most common cases,
while having the following advantages:

- It does not need to construct paths.
- It considers multiple outputs by `u`.
- It avoids iterator invalidation problems that path-based updates are prone to.

However, pathless updates do not support a few operators, most importantly
`try ... catch`.
In such cases, you can always fall back to path-based updates in jaq by writing
`getpath(path(p)) |= u`.

The following table shows how jaq executes an update `p |= u`.
In this table, the case for
`f as $x | g` assumes that
`f` yields outputs `f1`, ..., `fn`.

| `p`           | `p |= u` |
|:--------------|:---------|
| `.`           | `u` |
| `..`          | `def rec_up: (.[]? | rec_up), .; rec_up |= u` |
| `(f | g)`     | `f |= (g |= u)` |
| `(f , g)`     | `f |= u | g |= u` |
| `f as $x | g` | `(f1 as $x | g) |= u | ... | (fn as $x | g) |= u` |
| `f // g`      | `if first(f // false) then f |= u else g |= u` |
| `if $p then f else g end` | `if $p then f |= u else g |= u end` |

It follows from the table that `empty |= f` is equivalent to `.`.

The following list shows how update operators are executed,
depending on their input type:

- `.[] |= f`:

  - Array: `[.[] | f]`
  - Object: `with_entries(.[].value |= f)`
- `.[$i] |= f`:

  - Array (if `0 <= $i < length`): `.[:$i] + [.[$i] | first(f)] + .[$i+1:]`
  - Array (if `-length <= $i < 0`): `.[length + $i] |= f`
  - Object (if `has($i)`): `with_entries(.[] |= if .key == $i then {key, value: first(.value | f)})`
  - Object (if `has($i) | not`): `. + {($i): first(null | f)}`

The operators above throw an error if they encounter an unhandled case, whereas
the variants `.[]? |= f` and `.[$i] |= f` return their input in that case.


## Patterns

`. as {a: [$x, {("b", "c"): $y, $z}]} | $x, $y, $z`


## Modules

### `include "path";`

### `import "path" as mod;`

### `import "path" as $data;`


## Comments
